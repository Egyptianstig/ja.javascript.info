# コンストラクタ、 new 演算子

通常の `{...}` 構文では、1つのオブジェクトを作成できます。しかし、複数のユーザやメニューアイテムなど、似たようなオブジェクトを多数作成する必要がある場合もあります。

このようなことは、コンストラクタ関数と `"new"` 演算子を使うことで実現できます。

## コンストラクタ 関数 

コンストラクタ関数は技術的には通常の関数です。それには2つの慣習があります:

1. 名前は大文字で始めます。
2. `"new"` 演算子を使ってのみ実行されるべきです。

例:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

`new` 演算子を用いて関数が実行された場合、次のような処理が行われます:

1. 新しい空のオブジェクトが作成され、 `this` に割り当てられます。
2. 関数本体を実行します。通常は新しいプロパティを追加することで `this` に変更を加えます。
3. `this` の値が返されます。

つまり、`new User(...)` は次のようなことを行います:

```js
function User(name) {
*!*
  // this = {};  (暗黙)
*/!*

  // this へプロパティを追加
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (暗黙)
*/!*
}
```

したがって、`let user = new User("Jack")` は、以下と同じ結果となります:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

もし他のユーザを作りたいのであれば、`new User("Ann")`、`new User("Alice")` と言ったように呼び出すことができます。毎回リテラルを使うよりはるかに短く、また読みやすくなります。

再利用可能なオブジェクト作成のコードを実装すること、それがコンストラクタの主な目的です。

改めて留意しておきましょう。技術的にはどのような関数（`this` を持たないアロー関数を除く）でもコンストラクタとして使用できます。つまり、どの関数も `new` で実行することができ、上記のアルゴリズムが実行されることになります。"先頭が大文字" というのは、関数が `new` で実行されることを明確にするための共通の合意です。

````smart header="new function() { ... }"
1つの複雑なオブジェクトを作成するためのコードがたくさんある場合、次のように即座に呼び出されるコンストラクタ関数でラップすることができます:

```js
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...ユーザ作成のための他のコード。
  // 複雑なロジック、文
  // ローカル変数などを持つかもしれません。
};
```

このコンストラクタはどこにも保存されておらず、単に作って呼び出されただけなので再び呼び出すことはできません。したがってこのトリックは、将来の再利用は考えず、単一のオブジェクトを構成するコードをカプセル化することを目的としています。
````

## コンストラクタのモード評価: new.target 

```smart header="高度な内容"
このセクションで登場する構文はめったに使われませんので、スキップしても構いません。
```

関数の中では、`new.target` プロパティを使うことで、それが `new` で呼ばれたかそうでないかを確認することができます。

通常の呼び出しでは空であり、 `new` で呼び出された場合は関数と等しくなります:

```js run
function User() {
  alert(new.target);
}

// new なし:
*!*
User(); // undefined
*/!*

// new あり:
*!*
new User(); // function User { ... }
*/!*
```

これは、`new` をつけて呼び出された "コンストラクタモード" かそうではない "通常モード" かを知るために、関数内部で使用することができます。

`new` の場合と、通常呼び出し両方の構文が同じように動作するようにするために使用することもできます:

```js run
function User(name) {
  if (!new.target) { // new なしで実行した場合
    return new User(name); // ...new を追加します
  }

  this.name = name;
}

let john = User("John"); // new User へのリダイレクト
alert(john.name); // John
```

このアプローチは、構文をより柔軟にするためにライブラリの中で使われることがあります。使用者が `new` の有無に関わらず関数を呼び出すことができ、それでも動作させるようにさせています。

ただし、恐らくどこへでもこれを使うのは良いことではありません。なぜなら、 `new` を省略すると、何をしているのかが少し分かりにくくなるからです。 `new` があれば、新しいオブジェクトが作られることを知ることができます。

## コンストラクタからの返却 

通常、コンストラクタは `return` 文を持ちません。コンストラクタの仕事は必要なものをすべて `this` の中に書くことです。それが自動的に結果になります。

しかし、もし `return` 文があった場合はどうなるでしょう。ルールはシンプルです:

- もし `return` がオブジェクトと一緒に呼ばれた場合、`this` の代わりにそれを返します。
- もし `return` がプリミティブと一緒に呼ばれた場合、それは無視されます。

言い換えると、オブエジェクトの`return` はそのオブジェクトを返し、それ以外のケースでは `this` が返却されます。

例えば、ここで `return` は オブジェクトを返却することで、`this` を上書きします:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- オブジェクトを返す
}

alert( new BigUser().name );  // Godzilla, オブジェクトを取得 ^^
```

また、これは空の `return` の例です(`return` の後に プリミティブを置いた場合も同じです)

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- returns this
}

alert( new SmallUser().name );  // John
```

通常、コンストラクタは `return` 文を持ちません。ここでは、主に完全性のためにオブジェクトを返す特殊な動作について説明しています。

````smart header="丸括弧の省略"
ところで、もし引数を取らない場合は、`new` の後の丸括弧を省略することもできます。

```js
let user = new User; // <-- 括弧なし
// これと同じ
let user = new User();
```

丸括弧の省略は "良いスタイル" ではありませんが、仕様では許可されています。
````

## コンストラクタの中のメソッド 

オブジェクトを作るとき、コンストラクタ関数を使用することで高い柔軟性を得ることができます。コンストラクタ関数はオブジェクトがどのように組み立てられるか、その中に何を置くかを定義するパラメータを持っています。

もちろん、`this` にプロパティだけでなく、同様にメソッドも追加することができます。

例えば、下の `new User(name)` は `name` と メソッド `sayHi` を持つオブジェクトを作ります:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

*!*
let john = new User("John");

john.sayHi(); // My name is: John
*/!*

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

複雑なオブジェクトを作るために、より高度な構文 [classes](info:classes) があります。これに関しては後ほど説明します。

## サマリ 

- コンストラクタ関数、もしくは手短にコンストラクタ、は通常の関数ですが大文字から始まる名前を持つと言う共通の合意があります。
- コンストラクタ関数は `new` を使ってのみ呼び出されるべきです。この呼び出しは、最初に空の `this` を作成し、最後に追加された `this` を返すことを意味します。

複数の似たようなオブジェクトを作るときにコンストラクタ関数を使うことができます。

JavaScript は多くの組み込みのオブジェクトでコンストラクタを提供しています: 日付のための `Date`, セットのための `Set`、そしてその他私たちが学ぶ予定のものなどです。

```smart header="オブジェクト, 我々は戻ってきます!"
このチャプターでは、オブジェクトとコンストラクタについての基礎のみを説明しています。これらは、次のチャプターでデータ型と関数についてより深く学ぶために不可欠です。

それを学んだ後、チャプター <info:object-oriented-programming> では、オブジェクトに戻り、継承やクラスを含めそれらを詳細に説明します。
```
