# オブジェクトメソッド, "this"

オブジェクトは通常、ユーザや注文などのような、実世界のエンティティを表現するために作られます。:

```js
let user = {
  name: "John",
  age: 30
};
```

そして、実世界ではユーザは *アクション* することができます: ショッピングカードから何かを選んだり、ログイン、ログアウトなど。

アクションは、JavaScriptではプロパティの中で関数で表現されます。

## メソッド例 

スタートとして、`user` が Hello と言うようにしましょう:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

ここでは関数を作るために関数式を使い、それをオブジェクトの `user.sayHi` プロパティに代入しました。

その後、関数を呼ぶことができます。ユーザは今話すことができます!

オブジェクトのプロパティの関数は、*メソッド* と呼ばれます。

従って、ここではオブジェクト `user` のメソッド `sayHi` を作りました。

もちろん、次のように、宣言済みの関数をメソッドとして使うこともできます:

```js run
let user = {
  // ...
};

*!*
// 最初、宣言
function sayHi() {
  alert("Hello!");
};

// その後、メソッドを追加
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="オブジェクト指向プログラミング"
エンティティを表現するためにオブジェクトを使ってコードを書くとき、それは、[object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), 略すと "OOP" とばれます。

OOPは大きなものであり、それ自体の興味深い科学です。 正しいエンティティを選択するにはどうすればいいですか？ どのようにそれらの間の相互作用を整理しますか？それはアーキテクチャーであり、それらは E.Gamma, R.Helm, R.Johnson, J.Vissides による"Design Patterns: Elements of Reusable Object-Oriented Software" または G.Booch による "Object-Oriented Analysis and Design with Applications" などのような、そのトピックについての素晴らしい本があります。私たちは、チャプター <info:object-oriented-programming> の後半でそのトピックの表面について触れます。
```
### メソッドの短縮表現

オブジェクトリテラルでは、メソッドのための短縮構文があります:

```js
// これらのオブジェクトは同じことをします

let user = {
  sayHi: function() {
    alert("Hello");
  }
};

// メソッド簡略化はスッキリ見えますね
let user = {
*!*
  sayHi() { // "sayHi: function()" と同じです
*/!*
    alert("Hello");
  }
};
```

上の通り、`"function"` を除き、単に `sayHi()` と書くことができます。

実を言うと、この表記は完全に同一ではありません。オブジェクトの継承(後で説明します)に関して微妙な違いがあります。が、今のところは問題ありません。ほぼ全てのケースでこの短縮構文は好まれます。

## メソッド中の "this" 

オブジェクトのメソッドが処理をするために、オブジェクトに格納されている情報にアクセスする必要があることは一般的です。

例えば、`user.sayHi()` 内のコードが `user` の名前を必要とするかもしれません。

**オブジェクトにアクセスするために、メソッドは `this` キーワードを使うことができます。**

`this` の値はメソッドを呼び出すのに使われた "ドットの前" のオブジェクトです。

例:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" は "現在のオブジェクト"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

ここで `user.sayHi()` の実行中、`this` の値は `user` になります。

技術的には、外部変数を介して参照することで、`this` を使わずにオブジェクトにアクセスすることも可能です:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // "this" の代わりに "user"
*/!*
  }

};
```

...しかし、このようなコードは信頼性に欠けます。もし `user` を `admin = user` のように別の変数にコピーすることにし、何かで`user`を上書きすると、間違ったオブジェクトにアクセスすることになります。

次のような感じです:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // エラーにつながる
*/!*
  }

};


let admin = user;
user = null; // 明らかにするために上書きします

*!*
admin.sayHi(); // Whoops! sayHi() の中で古い名前が使われました! エラーです!
*/!*
```

`alert` の呼び出しで、`user.name` ではなく `this.name` を使うのであれば、コードは動作するでしょう。

## "this" はバインドされていません 

JavaScriptでは、 "this" キーワードは他のほとんどのプログラミング言語とは異なる振る舞いをします。オブジェクトのメソッドだけではなく、任意の関数内で使用することができます。

このようなコードも構文エラーにはなりません:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

`this` の値は、実行時にコンテキストに応じて評価されます。

例えば、ここでは同じ関数が2つの異なるオブジェクトに割り当てられており、呼び出しの際に異なる "this "が使われています:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// 2つのオブジェクトで同じ関数を使う
user.f = sayHi;
admin.f = sayHi;
*/!*

// これらの呼び出しは異なる this を持ちます
// 関数の中の "this" は "ドット" の前のオブジェクトです
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (ドットでも角括弧でも問題なくメソッドにアクセスできます)
```

ルールはシンプルです。`obj.f()` が呼び出されると、`f` の呼び出し中は `this` は `obj` です。つまり、上の例では `user` または `admin` となります。

````smart header="オブジェクトなしでの呼び出し: `this == undefined`"
オブジェクトがなくても関数を呼び出すことができます:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

このケースでは、 strict モードでは `this` は `undefined` になります。もし `this.name` にアクセスしようとするとエラーになります。

非 strict モード(誰かが `use strict` を忘れた場合)では、このようなケースでは `this` の値は *グローバルオブジェクト* (ブラウザでは `window`、後ほど学びます)になります。これは `"use strict"` で修正された歴史的な振る舞いです。

オブジェクトなしで `this` を使う関数の呼び出しは、一般的にプログラミングエラーであることに注意してください。関数の中に `this` がある場合、それはオブジェクトのコンテキストで呼ばれることを期待しています。
````

```smart header="バインドしていない `this` の結果"
もしあなたが他のプログラミング言語から来たのであれば、恐らく "バインドされた `this`" の考え方に慣れているでしょう。それは、オブジェクトに定義されたメソッドは常にそのオブジェクトを参照する `this` を持っている、と言うものです。

JavaScriptでは、 `this` は "自由" です。その値は実行時に評価され、メソッドが宣言されている場所には依存せず、 "ドットの前の" オブジェクトが何であるか、に依存します。

実行時に評価される `this` の概念は、プラスとマイナスの両方を持っています。一方では、1つの関数を異なるオブジェクトで再利用することができます。他方では、より大きな柔軟性は、ミスの招きやすさにつながります。

ここで、我々のポジションは、この言語設計上の決定が良いか悪いかを判断するものではありません。我々は、それをどうやって使うか、どうやって利益を得て、どのように問題を回避するかを理解するのです。
```

## アロー関数は "this" を持ちません 

アロー関数は特別で、それらは "自身の" `this` を持ちません。もしこのような関数で `this` を参照した場合、外部の "通常の" 関数から取得されます。

例えば、ここで `arrow()` は、外部の `user.sayHi()` メソッドから `this` を使います:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

これはアロー関数の特別な機能です。別の `this` ではなく、外側のコンテキストから取り出したい場合に便利です。<info:arrow-functions>のセクションの後半では、より多くのアロー関数を扱います。


## サマリ 

- オブジェクトのプロパティに格納されている関数は "メソッド" と呼ばれます。
- メソッドを使うと、オブジェクトは `object.doSomething()` のように "振る舞う" ことができます。
- メソッドはオブジェクトを `this` で参照することができます。

`this` の値は実行時に定義されます。
- 関数が宣言されている場合、`this` を使うことができますが、その `this` は関数が呼び出されるまで値を持っていません。
- その関数はオブジェクト間でコピーできます。
- 関数が "メソッド" 構文で呼び出されたとき: `object.method()`, 呼び出し中の `this` の値は、`object` です。

アロー関数は特別であることに注意してください: それは　`this` を持っていません。`this` がアロー関数の中でアクセスされるとき、それは外側から取得されます。
